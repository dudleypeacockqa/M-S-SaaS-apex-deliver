"""Subscription service layer for DEV-009: Subscription & Billing Management.

Handles Stripe integration, subscription lifecycle, and billing operations.
"""
import os
from datetime import datetime, timezone
from decimal import Decimal
from typing import Optional

import stripe
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.models.organization import Organization
from app.models.subscription import (
    Invoice,
    Subscription,
    SubscriptionStatus,
    SubscriptionTier,
)

# Initialize Stripe
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")


# ============================================================================
# Tier Configuration
# ============================================================================

TIER_CONFIG = {
    SubscriptionTier.STARTER: {
        "name": "Starter Plan",
        "price_monthly": Decimal("279.00"),
        "price_annual": Decimal("2790.00"),  # 10% discount
        "description": "Perfect for solo dealmakers and entrepreneurs",
        "stripe_price_id_monthly": os.getenv("STRIPE_PRICE_STARTER_MONTHLY", "price_starter_monthly"),
        "stripe_price_id_annual": os.getenv("STRIPE_PRICE_STARTER_ANNUAL", "price_starter_annual"),
        "features": {
            "max_deals": 10,
            "max_users": 3,
            "max_documents_per_deal": 50,
            "storage_gb": 5,
            "financial_intelligence": False,
            "deal_matching": False,
            "api_access": False,
            "priority_support": False,
            "custom_branding": False,
        },
    },
    SubscriptionTier.PROFESSIONAL: {
        "name": "Professional Plan",
        "price_monthly": Decimal("598.00"),
        "price_annual": Decimal("5980.00"),
        "description": "For growing M&A advisory firms",
        "stripe_price_id_monthly": os.getenv("STRIPE_PRICE_PROFESSIONAL_MONTHLY", "price_professional_monthly"),
        "stripe_price_id_annual": os.getenv("STRIPE_PRICE_PROFESSIONAL_ANNUAL", "price_professional_annual"),
        "features": {
            "max_deals": 50,
            "max_users": 10,
            "max_documents_per_deal": 200,
            "storage_gb": 50,
            "financial_intelligence": True,
            "deal_matching": True,
            "api_access": False,
            "priority_support": True,
            "custom_branding": False,
        },
    },
    SubscriptionTier.ENTERPRISE: {
        "name": "Enterprise Plan",
        "price_monthly": Decimal("1598.00"),
        "price_annual": Decimal("15980.00"),
        "description": "For large investment banks and corporate dev teams",
        "stripe_price_id_monthly": os.getenv("STRIPE_PRICE_ENTERPRISE_MONTHLY", "price_enterprise_monthly"),
        "stripe_price_id_annual": os.getenv("STRIPE_PRICE_ENTERPRISE_ANNUAL", "price_enterprise_annual"),
        "features": {
            "max_deals": 999,
            "max_users": 100,
            "max_documents_per_deal": 1000,
            "storage_gb": 500,
            "financial_intelligence": True,
            "deal_matching": True,
            "api_access": True,
            "priority_support": True,
            "custom_branding": True,
        },
    },
    SubscriptionTier.COMMUNITY: {
        "name": "Community Plan",
        "price_monthly": Decimal("2997.00"),
        "price_annual": Decimal("29970.00"),
        "description": "For industry influencers and event organizers",
        "stripe_price_id_monthly": os.getenv("STRIPE_PRICE_COMMUNITY_MONTHLY", "price_community_monthly"),
        "stripe_price_id_annual": os.getenv("STRIPE_PRICE_COMMUNITY_ANNUAL", "price_community_annual"),
        "features": {
            "max_deals": 999,
            "max_users": 999,
            "max_documents_per_deal": 2000,
            "storage_gb": 1000,
            "financial_intelligence": True,
            "deal_matching": True,
            "api_access": True,
            "priority_support": True,
            "custom_branding": True,
        },
    },
}


# ============================================================================
# Stripe Checkout Session
# ============================================================================


async def create_checkout_session(
    organization_id: str,
    tier: SubscriptionTier,
    billing_period: str = "monthly",
    success_url: str = None,
    cancel_url: str = None,
    db: AsyncSession = None,
) -> dict:
    """Create a Stripe Checkout Session for subscription purchase.

    Args:
        organization_id: Organization ID purchasing subscription
        tier: Subscription tier to purchase
        billing_period: "monthly" or "annual"
        success_url: URL to redirect after successful payment
        cancel_url: URL to redirect if payment canceled
        db: Database session

    Returns:
        dict with checkout_url and session_id
    """
    # Get organization
    result = await db.execute(select(Organization).filter(Organization.id == organization_id))
    organization = result.scalar_one_or_none()

    if not organization:
        raise ValueError("Organization not found")

    # Get tier configuration
    tier_config = TIER_CONFIG.get(tier)
    if not tier_config:
        raise ValueError(f"Invalid tier: {tier}")

    # Determine Stripe Price ID
    if billing_period == "annual":
        price_id = tier_config["stripe_price_id_annual"]
    else:
        price_id = tier_config["stripe_price_id_monthly"]

    # Default URLs if not provided
    if not success_url:
        success_url = f"{os.getenv('FRONTEND_URL', 'http://localhost:5173')}/dashboard?subscription=success"
    if not cancel_url:
        cancel_url = f"{os.getenv('FRONTEND_URL', 'http://localhost:5173')}/pricing?subscription=canceled"

    # Create or retrieve Stripe customer
    result = await db.execute(select(Subscription).filter(Subscription.organization_id == organization_id))
    existing_subscription = result.scalar_one_or_none()

    if existing_subscription and existing_subscription.stripe_customer_id:
        customer_id = existing_subscription.stripe_customer_id
    else:
        # Create new Stripe customer
        customer = stripe.Customer.create(
            email=f"org-{organization_id}@placeholder.com",  # TODO: Get actual email from user
            metadata={"organization_id": organization_id, "organization_name": organization.name},
        )
        customer_id = customer.id

    # Create Checkout Session
    session = stripe.checkout.Session.create(
        customer=customer_id,
        payment_method_types=["card"],
        line_items=[{"price": price_id, "quantity": 1}],
        mode="subscription",
        success_url=success_url,
        cancel_url=cancel_url,
        metadata={
            "organization_id": organization_id,
            "tier": tier.value,
            "billing_period": billing_period,
        },
        subscription_data={
            "trial_period_days": 14,  # 14-day free trial
            "metadata": {"organization_id": organization_id, "tier": tier.value},
        },
    )

    # Create or update subscription record with customer ID
    if not existing_subscription:
        new_subscription = Subscription(
            organization_id=organization_id,
            stripe_customer_id=customer_id,
            tier=tier,
            status=SubscriptionStatus.TRIALING,
        )
        db.add(new_subscription)
        await db.commit()

    return {"checkout_url": session.url, "session_id": session.id}


# ============================================================================
# Subscription Retrieval
# ============================================================================


async def get_organization_subscription(
    organization_id: str, db: AsyncSession
) -> Optional[Subscription]:
    """Get subscription for an organization.

    Args:
        organization_id: Organization ID
        db: Database session

    Returns:
        Subscription object or None
    """
    result = await db.execute(
        select(Subscription)
        .filter(Subscription.organization_id == organization_id)
        .options(selectinload(Subscription.organization))
    )
    return result.scalar_one_or_none()


# ============================================================================
# Subscription Updates (Tier Changes)
# ============================================================================


async def update_subscription_tier(
    organization_id: str,
    new_tier: SubscriptionTier,
    prorate: bool = True,
    db: AsyncSession = None,
) -> Subscription:
    """Update subscription tier (upgrade/downgrade).

    Args:
        organization_id: Organization ID
        new_tier: New subscription tier
        prorate: Whether to prorate the tier change
        db: Database session

    Returns:
        Updated Subscription object
    """
    subscription = await get_organization_subscription(organization_id, db)

    if not subscription:
        raise ValueError("No active subscription found")

    if not subscription.stripe_subscription_id:
        raise ValueError("Subscription not yet activated")

    # Get new tier config
    new_tier_config = TIER_CONFIG.get(new_tier)
    if not new_tier_config:
        raise ValueError(f"Invalid tier: {new_tier}")

    # Update Stripe subscription
    stripe_subscription = stripe.Subscription.retrieve(subscription.stripe_subscription_id)

    # Update the subscription item with new price
    stripe.Subscription.modify(
        subscription.stripe_subscription_id,
        items=[
            {
                "id": stripe_subscription["items"]["data"][0].id,
                "price": new_tier_config["stripe_price_id_monthly"],  # TODO: Support annual
            }
        ],
        proration_behavior="create_prorations" if prorate else "none",
    )

    # Update database
    subscription.tier = new_tier
    subscription.updated_at = datetime.now(timezone.utc)
    await db.commit()
    await db.refresh(subscription)

    return subscription


# ============================================================================
# Subscription Cancellation
# ============================================================================


async def cancel_subscription(
    organization_id: str, immediately: bool = False, db: AsyncSession = None
) -> Subscription:
    """Cancel a subscription.

    Args:
        organization_id: Organization ID
        immediately: Cancel immediately (True) or at period end (False)
        db: Database session

    Returns:
        Updated Subscription object
    """
    subscription = await get_organization_subscription(organization_id, db)

    if not subscription:
        raise ValueError("No active subscription found")

    if not subscription.stripe_subscription_id:
        raise ValueError("Subscription not yet activated")

    # Cancel in Stripe
    if immediately:
        stripe.Subscription.delete(subscription.stripe_subscription_id)
        subscription.status = SubscriptionStatus.CANCELED
        subscription.canceled_at = datetime.now(timezone.utc)
    else:
        stripe.Subscription.modify(
            subscription.stripe_subscription_id, cancel_at_period_end=True
        )
        subscription.cancel_at_period_end = True

    subscription.updated_at = datetime.now(timezone.utc)
    await db.commit()
    await db.refresh(subscription)

    return subscription


# ============================================================================
# Webhook Event Handlers
# ============================================================================


async def handle_checkout_completed(event_data: dict, db: AsyncSession) -> None:
    """Handle checkout.session.completed webhook.

    Args:
        event_data: Stripe event data
        db: Database session
    """
    session = event_data["object"]
    organization_id = session["metadata"]["organization_id"]
    stripe_subscription_id = session["subscription"]
    stripe_customer_id = session["customer"]

    # Retrieve subscription from Stripe
    stripe_subscription = stripe.Subscription.retrieve(stripe_subscription_id)

    # Update database subscription
    result = await db.execute(
        select(Subscription).filter(Subscription.organization_id == organization_id)
    )
    subscription = result.scalar_one_or_none()

    if subscription:
        subscription.stripe_subscription_id = stripe_subscription_id
        subscription.stripe_customer_id = stripe_customer_id
        subscription.status = SubscriptionStatus.ACTIVE
        subscription.current_period_start = datetime.fromtimestamp(
            stripe_subscription["current_period_start"], tz=timezone.utc
        )
        subscription.current_period_end = datetime.fromtimestamp(
            stripe_subscription["current_period_end"], tz=timezone.utc
        )
        subscription.updated_at = datetime.now(timezone.utc)
        await db.commit()


async def handle_invoice_paid(event_data: dict, db: AsyncSession) -> None:
    """Handle invoice.paid webhook.

    Args:
        event_data: Stripe event data
        db: Database session
    """
    invoice_data = event_data["object"]
    stripe_invoice_id = invoice_data["id"]
    stripe_customer_id = invoice_data["customer"]

    # Find subscription by customer ID
    result = await db.execute(
        select(Subscription).filter(Subscription.stripe_customer_id == stripe_customer_id)
    )
    subscription = result.scalar_one_or_none()

    if not subscription:
        return

    # Create invoice record
    invoice = Invoice(
        organization_id=subscription.organization_id,
        subscription_id=subscription.id,
        stripe_invoice_id=stripe_invoice_id,
        amount=Decimal(str(invoice_data["amount_paid"] / 100)),  # Convert cents to currency
        currency=invoice_data["currency"].upper(),
        status="paid",
        paid_at=datetime.fromtimestamp(invoice_data["status_transitions"]["paid_at"], tz=timezone.utc),
        invoice_pdf=invoice_data.get("invoice_pdf"),
    )
    db.add(invoice)
    await db.commit()


async def handle_subscription_updated(event_data: dict, db: AsyncSession) -> None:
    """Handle customer.subscription.updated webhook.

    Args:
        event_data: Stripe event data
        db: Database session
    """
    subscription_data = event_data["object"]
    stripe_subscription_id = subscription_data["id"]

    # Find subscription
    result = await db.execute(
        select(Subscription).filter(Subscription.stripe_subscription_id == stripe_subscription_id)
    )
    subscription = result.scalar_one_or_none()

    if not subscription:
        return

    # Update subscription status
    subscription.status = SubscriptionStatus(subscription_data["status"].upper())
    subscription.current_period_start = datetime.fromtimestamp(
        subscription_data["current_period_start"], tz=timezone.utc
    )
    subscription.current_period_end = datetime.fromtimestamp(
        subscription_data["current_period_end"], tz=timezone.utc
    )
    subscription.cancel_at_period_end = subscription_data.get("cancel_at_period_end", False)

    if subscription_data.get("canceled_at"):
        subscription.canceled_at = datetime.fromtimestamp(
            subscription_data["canceled_at"], tz=timezone.utc
        )

    subscription.updated_at = datetime.now(timezone.utc)
    await db.commit()


async def handle_subscription_deleted(event_data: dict, db: AsyncSession) -> None:
    """Handle customer.subscription.deleted webhook.

    Args:
        event_data: Stripe event data
        db: Database session
    """
    subscription_data = event_data["object"]
    stripe_subscription_id = subscription_data["id"]

    # Find subscription
    result = await db.execute(
        select(Subscription).filter(Subscription.stripe_subscription_id == stripe_subscription_id)
    )
    subscription = result.scalar_one_or_none()

    if not subscription:
        return

    # Mark as canceled
    subscription.status = SubscriptionStatus.CANCELED
    subscription.canceled_at = datetime.now(timezone.utc)
    subscription.updated_at = datetime.now(timezone.utc)
    await db.commit()
